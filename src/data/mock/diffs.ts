import { DiffFile } from '@/lib/types';

export const mockDiffs: Record<string, DiffFile[]> = {
  'task-5': [
    {
      path: 'src/api/tasks/graph.ts',
      additions: 87,
      deletions: 12,
      hunks: [
        {
          header: '@@ -1,15 +1,102 @@',
          lines: [
            { type: 'context', content: "import { prisma } from '@/lib/db';", lineNumber: 1 },
            { type: 'context', content: "import { Task } from '@/lib/types';", lineNumber: 2 },
            { type: 'add', content: "import { detectCycles, topologicalSort } from '@/lib/graph';", lineNumber: 3 },
            { type: 'context', content: '', lineNumber: 4 },
            { type: 'remove', content: 'export async function getTaskGraph() {' },
            { type: 'add', content: 'export async function getTaskGraph(filters?: GraphFilters) {' },
            { type: 'add', content: '  const tasks = await prisma.task.findMany({' },
            { type: 'add', content: '    where: filters?.changeId ? { changeId: filters.changeId } : undefined,' },
            { type: 'add', content: '    include: { dependencies: true, evidence: true },' },
            { type: 'add', content: '  });' },
            { type: 'add', content: '' },
            { type: 'add', content: '  const nodes = tasks.map(toGraphNode);' },
            { type: 'add', content: '  const edges = tasks.flatMap(t =>' },
            { type: 'add', content: "    t.dependencies.map(d => ({ from: d.id, to: t.id, type: 'blocks' as const }))" },
            { type: 'add', content: '  );' },
            { type: 'add', content: '' },
            { type: 'add', content: '  // Detect cycles before returning' },
            { type: 'add', content: '  const cycles = detectCycles(nodes, edges);' },
            { type: 'add', content: '  if (cycles.length > 0) {' },
            { type: 'add', content: "    console.warn('Dependency cycles detected:', cycles);" },
            { type: 'add', content: '  }' },
            { type: 'add', content: '' },
            { type: 'add', content: '  const sorted = topologicalSort(nodes, edges);' },
            { type: 'add', content: '  const criticalPath = findCriticalPath(sorted, edges);' },
            { type: 'add', content: '' },
            { type: 'add', content: '  return { nodes, edges, criticalPath, cycles };' },
            { type: 'context', content: '}', lineNumber: 28 },
          ],
        },
      ],
    },
    {
      path: 'src/lib/graph.ts',
      additions: 45,
      deletions: 0,
      hunks: [
        {
          header: '@@ -0,0 +1,45 @@',
          lines: [
            { type: 'add', content: "// Graph utilities for dependency analysis" },
            { type: 'add', content: '' },
            { type: 'add', content: 'interface GraphNode { id: string; }' },
            { type: 'add', content: "interface GraphEdge { from: string; to: string; type: 'blocks'; }" },
            { type: 'add', content: '' },
            { type: 'add', content: 'export function detectCycles(nodes: GraphNode[], edges: GraphEdge[]): string[][] {' },
            { type: 'add', content: "  const visited = new Set<string>();" },
            { type: 'add', content: "  const inStack = new Set<string>();" },
            { type: 'add', content: '  const cycles: string[][] = [];' },
            { type: 'add', content: '' },
            { type: 'add', content: '  function dfs(nodeId: string, path: string[]): void {' },
            { type: 'add', content: '    visited.add(nodeId);' },
            { type: 'add', content: '    inStack.add(nodeId);' },
            { type: 'add', content: '' },
            { type: 'add', content: '    const neighbors = edges.filter(e => e.from === nodeId).map(e => e.to);' },
            { type: 'add', content: '    for (const neighbor of neighbors) {' },
            { type: 'add', content: '      if (inStack.has(neighbor)) {' },
            { type: 'add', content: '        cycles.push([...path, neighbor]);' },
            { type: 'add', content: '      } else if (!visited.has(neighbor)) {' },
            { type: 'add', content: '        dfs(neighbor, [...path, neighbor]);' },
            { type: 'add', content: '      }' },
            { type: 'add', content: '    }' },
            { type: 'add', content: '    inStack.delete(nodeId);' },
            { type: 'add', content: '  }' },
            { type: 'add', content: '' },
            { type: 'add', content: '  nodes.forEach(n => { if (!visited.has(n.id)) dfs(n.id, [n.id]); });' },
            { type: 'add', content: '  return cycles;' },
            { type: 'add', content: '}' },
          ],
        },
      ],
    },
    {
      path: 'tests/api/graph.test.ts',
      additions: 34,
      deletions: 2,
      hunks: [
        {
          header: '@@ -1,5 +1,39 @@',
          lines: [
            { type: 'context', content: "import { describe, it, expect } from 'vitest';", lineNumber: 1 },
            { type: 'remove', content: "import { getTaskGraph } from '@/api/tasks/graph';" },
            { type: 'add', content: "import { getTaskGraph } from '@/api/tasks/graph';" },
            { type: 'add', content: "import { detectCycles, topologicalSort } from '@/lib/graph';" },
            { type: 'context', content: '', lineNumber: 3 },
            { type: 'remove', content: "describe('getTaskGraph', () => {" },
            { type: 'add', content: "describe('Task Graph API', () => {" },
            { type: 'add', content: "  it('returns nodes and edges', async () => {" },
            { type: 'add', content: '    const result = await getTaskGraph();' },
            { type: 'add', content: '    expect(result.nodes).toBeDefined();' },
            { type: 'add', content: '    expect(result.edges).toBeDefined();' },
            { type: 'add', content: '  });' },
            { type: 'add', content: '' },
            { type: 'add', content: "  it('detects cycles', () => {" },
            { type: 'add', content: "    const nodes = [{ id: 'a' }, { id: 'b' }];" },
            { type: 'add', content: "    const edges = [{ from: 'a', to: 'b', type: 'blocks' as const }, { from: 'b', to: 'a', type: 'blocks' as const }];" },
            { type: 'add', content: '    expect(detectCycles(nodes, edges).length).toBeGreaterThan(0);' },
            { type: 'add', content: '  });' },
            { type: 'add', content: '' },
            { type: 'add', content: "  it('filters by changeId', async () => {" },
            { type: 'add', content: "    const result = await getTaskGraph({ changeId: 'change-auth' });" },
            { type: 'add', content: "    result.nodes.forEach(n => expect(n.changeId).toBe('change-auth'));" },
            { type: 'add', content: '  });' },
          ],
        },
      ],
    },
  ],
};
